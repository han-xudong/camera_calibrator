(()=>{var e,t,r,o,n,l,s={1333:(e,t,r)=>{"use strict";var o=r(4117),n=r(6927);function l(e){let t=0,r=0;e.forEach(e=>{t+=e.x,r+=e.y}),t/=e.length,r/=e.length;let n=0;e.forEach(e=>{n+=Math.sqrt((e.x-t)**2+(e.y-r)**2)});let l=Math.sqrt(2)/(n/=e.length),s=new o.uq([[l,0,-l*t],[0,l,-l*r],[0,0,1]]);return{points:e.map(e=>{let t=new o.uq([[e.x],[e.y],[1]]),r=s.mmul(t);return{x:r.get(0,0),y:r.get(1,0)}}),T:s}}function s(e){let t=Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);if(t<1e-8)return o.uq.eye(3);let r=new o.uq([[e[0]/t],[e[1]/t],[e[2]/t]]),n=new o.uq([[0,-r.get(2,0),r.get(1,0)],[r.get(2,0),0,-r.get(0,0)],[-r.get(1,0),r.get(0,0),0]]),l=o.uq.eye(3),s=n.mmul(n),a=n.mul(Math.sin(t)),i=s.mul(1-Math.cos(t));return l.add(a).add(i)}let a=null,i=null,u=null,c=null,g=null,f="",d=null,p=!1;async function m(){if(!p)return self.postMessage({type:"PROGRESS",message:"Loading OpenCV..."}),new Promise((e,t)=>{let r={onRuntimeInitialized:()=>{console.log("[Worker] OpenCV Runtime Initialized via Module callback"),d=self.cv&&self.cv.Mat?self.cv:r,p=!0,e()},onError:e=>{console.error("[Worker] OpenCV Module Error:",e)},print:e=>console.log("[OpenCV]",e),printErr:e=>console.warn("[OpenCV]",e)};self.Module=r,self.module=void 0,self.exports=void 0,self.define=void 0,self.window||(self.window=self);let o=0,n=setInterval(()=>{o++;let t=self.cv;t&&t.Mat&&t.findChessboardCorners?(clearInterval(n),p||(console.log("[Worker] OpenCV (fully loaded) found via Polling"),d=t,p=!0,e())):t&&t.Mat&&!t.findChessboardCorners?o%10==0&&console.log("[Worker] OpenCV found but findChessboardCorners missing. Waiting..."):"function"==typeof t&&!p&&o<5&&(console.log("[Worker] cv is function, attempting call..."),Promise.resolve(t(r)).then(t=>{d=t,p=!0,e()}).catch(()=>{})),o>200&&o%50==0&&console.warn("[Worker] Still waiting for OpenCV...")},100);console.log("[Worker] Loading OpenCV script...");try{self.location.origin;let e=["opencv.js","/opencv.js","/camera_calibrator/opencv.js"];if(f){let t=f.substring(0,f.lastIndexOf("/")+1);e.unshift(t+"opencv.js")}let t=!1;for(let r of e)try{importScripts(r),t=!0,console.log(`[Worker] Loaded OpenCV from ${r}`);break}catch(e){}if(!t)throw Error("Could not load opencv.js from standard paths");console.log("[Worker] importScripts executed")}catch(e){console.warn("[Worker] Local load failed, trying CDN",e);try{importScripts("https://docs.opencv.org/4.5.0/opencv.js")}catch(e){t(Error(`Failed to load OpenCV: ${e}`))}}})}async function h(e,t){let{boardType:r}=t;if("aprilgrid"===r){if(!a)throw Error("AprilTag not initialized");return function({imageData:e}){let{width:t,height:r,data:o}=e,n=new Uint8Array(t*r);for(let e=0;e<t*r;e++){let t=o[4*e],r=o[4*e+1],l=o[4*e+2];n[e]=.299*t+.587*r+.114*l}let l=c(t,r,t);if(0===l)throw Error("Failed to allocate memory for image in WASM");a.HEAPU8.set(n,l);let s=i();if(0===s)return{found:!1,detections:[],error:"WASM Internal Error: Returned NULL pointer"};let u=a.getValue(s,"i32"),g=a.getValue(s+4,"i32");if(g>0&&0!==u)try{let e=a.HEAPU8.subarray(u,u+g),t=new TextDecoder("utf8").decode(e);if(!(t=t.replace(/\u0000/g,"")).trim().startsWith("["))return{found:!1,detections:[],error:`WASM Output Error: ${t}`};let r=JSON.parse(t);return{found:r.length>0,detections:r}}catch(e){return{found:!1,detections:[],error:`JSON Parse Error: ${e.message}`}}return{found:!1,detections:[],error:"No detection result returned from WASM"}}({imageData:e})}if("checkerboard"===r||"chessboard"===r){if(await m(),!d||!d.findChessboardCorners)throw Error("OpenCV loaded but calibration functions are missing. Please replace public/opencv.js with a full build (including calib3d).");return function(e,t){try{let{rows:r,cols:o}=t;if(console.log(`[Worker] Detecting Chessboard: ${o}x${r} (inner corners)`),!d)return console.error("[Worker] OpenCV not loaded"),{found:!1,corners:[],error:"OpenCV not loaded"};let n=d.matFromImageData(e),l=new d.Mat;d.cvtColor(n,l,d.COLOR_RGBA2GRAY);let s=new d.Mat,a=new d.Size(o,r);console.log(`[Worker] Attempt 1: ${o}x${r}`);let i=d.findChessboardCorners(l,a,s,3);if(i||(console.log("[Worker] Attempt 1 failed. Trying (cols-1)x(rows-1)..."),a=new d.Size(o-1,r-1),i=d.findChessboardCorners(l,a,s,3)),i||(console.log("[Worker] Attempt 2 failed. Trying swapped cols/rows..."),a=new d.Size(r,o),i=d.findChessboardCorners(l,a,s,3)),i){console.log(`[Worker] Checkerboard found! Size: ${a.width}x${a.height}`);let e=new d.Size(5,5),t=new d.Size(-1,-1),r=new d.TermCriteria(d.TERM_CRITERIA_EPS+d.TERM_CRITERIA_COUNT,30,.001);d.cornerSubPix(l,s,e,t,r);let o=[];for(let e=0;e<s.rows;++e)o.push({x:s.data32F[2*e],y:s.data32F[2*e+1]});return n.delete(),l.delete(),s.delete(),{found:!0,corners:o}}return console.log("[Worker] Checkerboard NOT found."),n.delete(),l.delete(),s.delete(),{found:!1,corners:[],error:"Checkerboard pattern not found. Tried normal, inner-corners, and swapped dimensions."}}catch(e){return console.error("OpenCV Checkerboard Error:",e),{found:!1,corners:[],error:`OpenCV Error: ${e.message||e}`}}}(e,t)}if("charuco"===r)throw Error("ChArUco detection not yet implemented in worker.");throw Error(`Unknown board type: ${r}`)}async function y(e){if(!a)return new Promise((t,r)=>{let o=new URL(e,self.location.origin).toString();self.Module={locateFile:t=>t.endsWith(".wasm")?new URL("apriltag.wasm",e.substring(0,e.lastIndexOf("/")+1)).toString():t,onRuntimeInitialized:()=>{console.log("AprilTag WASM Initialized")}},importScripts(o),self.postMessage({type:"PROGRESS",message:"Loading AprilTag WASM..."});let n=async()=>{if(self.AprilTagWasm)try{self.postMessage({type:"PROGRESS",message:"Initializing AprilTag..."});let e=new Promise(async(e,t)=>{let r=setTimeout(()=>t(Error("AprilTagWasm factory timeout")),1e4);try{let t=await self.AprilTagWasm(self.Module);clearTimeout(r),e(t)}catch(e){clearTimeout(r),t(e)}});u=(a=await e).cwrap("atagjs_init","number",[]),a.cwrap("atagjs_destroy","number",[]),g=a.cwrap("atagjs_set_detector_options","number",["number","number","number","number","number","number","number"]),c=a.cwrap("atagjs_set_img_buffer","number",["number","number","number"]),i=a.cwrap("atagjs_detect","number",[]);let r=u();console.log("atag_init returned:",r),g(2,0,1,1,10,0,0),console.log("AprilTag WASM Initialized (Safe Options Set)"),t()}catch(e){console.error("AprilTag WASM Init Failed:",e),r(e)}else setTimeout(n,100)};n()})}self.onmessage=async e=>{let{type:t,payload:r,id:a}=e.data;try{switch(t){case"INIT":f=r.url,await y(r.url),self.postMessage({type:"INIT_SUCCESS",id:a});break;case"DETECT":let e=await h(r.imageData,r.settings);self.postMessage({type:"DETECT_SUCCESS",id:a,payload:e});break;case"CALIBRATE":let i=function(e,t,r){let a,i,u,c,g,f,d,p,m,h,y,w,C,b,S=[],{points:E,T:v}=l(t);for(let t of e){let{points:e,T:r}=l(t),n=function(e,t){let r=e.length,n=[];for(let o=0;o<r;o++){let r=e[o].x,l=e[o].y,s=t[o].x,a=t[o].y;n.push([-r,-l,-1,0,0,0,s*r,s*l,s]),n.push([0,0,0,-r,-l,-1,a*r,a*l,a])}let l=new o.uq(n),s=new o.W2(l).rightSingularVectors.getColumn(8),a=new o.uq(3,3);return a.set(0,0,s[0]),a.set(0,1,s[1]),a.set(0,2,s[2]),a.set(1,0,s[3]),a.set(1,1,s[4]),a.set(1,2,s[5]),a.set(2,0,s[6]),a.set(2,1,s[7]),a.set(2,2,s[8]),a}(E,e),s=(0,o.DI)(r).mmul(n).mmul(v);s.div(s.get(2,2)),S.push(s)}let M=(a=new o.uq(2*S.length,6),i=(e,t,r)=>{let o=e.getColumn(t),n=e.getColumn(r);return[o[0]*n[0],o[0]*n[1]+o[1]*n[0],o[1]*n[1],o[2]*n[0]+o[0]*n[2],o[2]*n[1]+o[1]*n[2],o[2]*n[2]]},S.forEach((e,t)=>{let r=i(e,0,1),o=i(e,0,0),n=i(e,1,1),l=o.map((e,t)=>e-n[t]);for(let e=0;e<6;e++)a.set(2*t,e,r[e]),a.set(2*t+1,e,l[e])}),c=(u=new o.W2(a).rightSingularVectors.getColumn(5))[0],g=u[1],f=u[2],d=u[3],p=u[4],m=u[5],h=(g*d-c*p)/(c*f-g*g),y=m-(d*d+h*(g*d-c*p))/c,w=Math.sqrt(Math.abs(y/c)),C=Math.sqrt(Math.abs(y*c/(c*f-g*g))),b=-g*w*w*C/y,{fx:w,fy:C,cx:b*h/C-d*w*w/y,cy:h,skew:b}),x=new o.uq([[M.fx,M.skew,M.cx],[0,M.fy,M.cy],[0,0,1]]),O=S.map(e=>(function(e,t){let r=(0,o.DI)(t),n=e.getColumn(0),l=e.getColumn(1),s=e.getColumn(2),a=new o.uq(3,1);for(let e=0;e<3;e++)a.set(e,0,n[e]);a.norm();let i=new o.uq(3,1);for(let e=0;e<3;e++)i.set(e,0,n[e]);let u=new o.uq(3,1);for(let e=0;e<3;e++)u.set(e,0,l[e]);let c=new o.uq(3,1);for(let e=0;e<3;e++)c.set(e,0,s[e]);let g=r.mmul(i),f=r.mmul(u),d=r.mmul(c),p=1/g.norm(),m=g.mul(p),h=f.mul(p),y=new o.uq([[m.get(1,0)*h.get(2,0)-m.get(2,0)*h.get(1,0)],[m.get(2,0)*h.get(0,0)-m.get(0,0)*h.get(2,0)],[m.get(0,0)*h.get(1,0)-m.get(1,0)*h.get(0,0)]]),w=d.mul(p),C=new o.uq(3,3);C.setColumn(0,m.to1DArray()),C.setColumn(1,h.to1DArray()),C.setColumn(2,y.to1DArray());let b=new o.W2(C),S=b.leftSingularVectors.mmul(b.rightSingularVectors.transpose());if(0>w.get(2,0)){w.mul(-1),m.mul(-1),h.mul(-1),C.setColumn(0,m.to1DArray()),C.setColumn(1,h.to1DArray()),C.setColumn(2,y.to1DArray());let e=new o.W2(C);return{R:e.leftSingularVectors.mmul(e.rightSingularVectors.transpose()),t:w}}return{R:S,t:w}})(e,x)),T=[M.fx,M.fy,M.cx,M.cy,0,0];O.forEach(e=>{let t=function(e){let t=(e.trace()-1)/2;t>1&&(t=1),t<-1&&(t=-1);let r=Math.acos(t);if(1e-8>Math.abs(r))return[0,0,0];let o=r/(2*Math.sin(r)),n=(e.get(2,1)-e.get(1,2))*o,l=(e.get(0,2)-e.get(2,0))*o;return[n,l,(e.get(1,0)-e.get(0,1))*o]}(e.R);T.push(t[0],t[1],t[2]),T.push(e.t.get(0,0),e.t.get(1,0),e.t.get(2,0))});let k=[],A=[];e.forEach((e,t)=>{e.forEach((e,r)=>{k.push([t,r,0]),A.push(e.x),k.push([t,r,1]),A.push(e.y)})});try{let r=(0,n.s)({x:k,y:A},e=>{let[r,n,l,a,i,u]=e,c=[];for(let t=0;t<O.length;t++){let r=6+6*t,n=[e[r],e[r+1],e[r+2]],l=[e[r+3],e[r+4],e[r+5]];c.push({R:s(n),t:new o.uq([[l[0]],[l[1]],[l[2]]])})}return e=>{let s=e[0],g=e[1],f=1===e[2],{R:d,t:p}=c[s],m=t[g],h=new o.uq([[m.x],[m.y],[0]]),y=d.mmul(h).add(p),w=y.get(2,0);if(1e-6>Math.abs(w))return 0;let C=y.get(0,0)/w,b=y.get(1,0)/w,S=C*C+b*b,E=S*S;return f?b*(1+i*S+u*E)*n+a:C*(1+i*S+u*E)*r+l}},{damping:1.5,initialValues:T,gradientDifference:.1,maxIterations:50,errorTolerance:.01}),l=r.parameterValues||r,[a,i,u,c,g,f]=l,d=Math.sqrt((r.parameterError||0)/A.length),p=[],m=new o.uq([[a,0,u],[0,i,c],[0,0,1]]),h=[g,f,0,0,0];return e.forEach((e,r)=>{let n=6+6*r,a=[l[n],l[n+1],l[n+2]],i=[l[n+3],l[n+4],l[n+5]],u=s(a),c=new o.uq([[i[0]],[i[1]],[i[2]]]),g=0;e.forEach((e,r)=>{var n,l;let s,a,i,f,d,p,y,w,C,b,S,E,v=t[r],M=(n=v.x,l=v.y,s=new o.uq([[n],[l],[0]]),i=(a=u.mmul(s).add(c)).get(0,0)/a.get(2,0),f=a.get(1,0)/a.get(2,0),p=(d=i*i+f*f)*d,y=h[0]||0,w=h[1]||0,C=m.get(0,0),b=m.get(1,1),S=m.get(0,2),E=m.get(1,2),{u:i*(1+y*d+w*p)*C+S,v:f*(1+y*d+w*p)*b+E}),x=(M.u-e.x)**2+(M.v-e.y)**2;g+=x});let f=g/e.length;p.push(Math.sqrt(f))}),{cameraMatrix:[a,0,u,0,i,c,0,0,1],distCoeffs:[g,f,0,0,0],rms:d,perViewErrors:p,rvecs:O.map((e,t)=>{let r=6+6*t;return[l[r],l[r+1],l[r+2]]}),tvecs:O.map((e,t)=>{let r=6+6*t;return[l[r+3],l[r+4],l[r+5]]})}}catch(e){return console.error("Calibration optimization failed:",e),{cameraMatrix:[M.fx,0,M.cx,0,M.fy,M.cy,0,0,1],distCoeffs:[0,0,0,0,0],rms:-1,perViewErrors:[],rvecs:O.map(e=>[0,0,0]),tvecs:O.map(e=>[e.t.get(0,0),e.t.get(1,0),e.t.get(2,0)])}}}(r.allImagePoints,r.objPoints,r.imageSize);self.postMessage({type:"CALIBRATE_SUCCESS",id:a,payload:i});break;default:throw Error(`Unknown message type: ${t}`)}}catch(e){self.postMessage({type:"ERROR",id:a,error:e.message})}}}},a={};function i(e){var t=a[e];if(void 0!==t)return t.exports;var r=a[e]={exports:{}},o=!0;try{s[e](r,r.exports,i),o=!1}finally{o&&delete a[e]}return r.exports}i.m=s,i.x=()=>{var e=i.O(void 0,[927],()=>i(1333));return i.O(e)},e=[],i.O=(t,r,o,n)=>{if(r){n=n||0;for(var l=e.length;l>0&&e[l-1][2]>n;l--)e[l]=e[l-1];e[l]=[r,o,n];return}for(var s=1/0,l=0;l<e.length;l++){for(var[r,o,n]=e[l],a=!0,u=0;u<r.length;u++)(!1&n||s>=n)&&Object.keys(i.O).every(e=>i.O[e](r[u]))?r.splice(u--,1):(a=!1,n<s&&(s=n));if(a){e.splice(l--,1);var c=o();void 0!==c&&(t=c)}}return t},i.d=(e,t)=>{for(var r in t)i.o(t,r)&&!i.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},i.f={},i.e=e=>Promise.all(Object.keys(i.f).reduce((t,r)=>(i.f[r](e,t),t),[])),i.u=e=>"static/chunks/"+e+".3fd8a9bb48a63997.js",i.miniCssF=e=>{},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.tt=()=>(void 0===t&&(t={createScriptURL:e=>e},"undefined"!=typeof trustedTypes&&trustedTypes.createPolicy&&(t=trustedTypes.createPolicy("nextjs#bundler",t))),t),i.tu=e=>i.tt().createScriptURL(e),i.p="/camera_calibrator/_next/",r={333:1},i.f.i=(e,t)=>{r[e]||importScripts(i.tu(i.p+i.u(e)))},n=(o=self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push.bind(o),o.push=e=>{var[t,o,l]=e;for(var s in o)i.o(o,s)&&(i.m[s]=o[s]);for(l&&l(i);t.length;)r[t.pop()]=1;n(e)},l=i.x,i.x=()=>i.e(927).then(l),_N_E=i.x()})();